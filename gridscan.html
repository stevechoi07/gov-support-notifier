<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GridScan v1.4 (안정성 및 UX 개선)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="text/javascript" src="//dapi.kakao.com/v2/maps/sdk.js?appkey=Bdae71c83941e7abbe59827c2625be7b&libraries=services"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap');
        body { font-family: 'Noto Sans KR', sans-serif; background-color: #f8f9fa; color: #212529; }
        .main-container { background-color: #ffffff; border: 1px solid #dee2e6; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); }
        .title-text { color: #14b8a6; }
        .search-button { background-color: #14b8a6; color: #ffffff; transition: all 0.2s ease-in-out; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .search-button:hover { background-color: #0d9488; transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.15); }
        .search-button:disabled { background-color: #94a3b8; cursor: not-allowed; transform: none; box-shadow: none; }
        /* v1.4: 중단 버튼 스타일 추가 */
        .cancel-button { background-color: #ef4444; color: #ffffff; transition: all 0.2s ease-in-out; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .cancel-button:hover { background-color: #dc2626; transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.15); }
        .progress-bar { background-color: #e9ecef; border-radius: 9999px; overflow: hidden; }
        .progress-bar-fill { background-color: #14b8a6; transition: width 0.3s ease-in-out; }
        .result-table { width: 100%; border-collapse: collapse; }
        .result-table th, .result-table td { border: 1px solid #dee2e6; padding: 0.75rem; text-align: left; }
        .result-table thead { background-color: #f1f5f9; }
        .result-table tbody tr:nth-child(even) { background-color: #f8fafc; }
        .status-pass { color: #16a34a; font-weight: bold; }
        .status-fail { color: #ef4444; font-weight: bold; }
        .address-counter.over-limit { color: #ef4444; font-weight: bold; }
        
        /* v1.4: 토스트 알림 스타일 추가 */
        .toast-notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: #212529;
            color: #ffffff;
            padding: 1rem 1.5rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            transform: translateX(120%);
            transition: transform 0.3s ease-in-out;
            z-index: 1000;
            opacity: 0;
        }
        .toast-notification.show {
            transform: translateX(0);
            opacity: 1;
        }
        .toast-notification.error {
            background-color: #dc2626;
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen p-4">

    <div class="main-container w-full max-w-4xl mx-auto rounded-2xl p-6 sm:p-8 space-y-8">
        
        <div class="text-center space-y-2">
            <h1 class="text-3xl sm:text-4xl font-bold title-text">⚡️ GridScan v1.4 ⚡️</h1>
            <p class="text-gray-600 text-sm sm:text-base">여러 주소를 한 번에 분석하고 결과를 받아보세요.</p>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
            <div>
                <div class="flex justify-between items-center mb-2">
                    <label for="address-list" class="block text-lg font-semibold text-gray-700">주소 목록 붙여넣기</label>
                    <span id="address-counter" class="text-sm font-medium text-gray-500">0 / 200 개</span>
                </div>
                <textarea id="address-list" rows="10" class="w-full p-3 border-2 border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-teal-500" placeholder="예:&#10;경기도 성남시 중원구 도촌남로 101&#10;경기도 고양시 덕양구 향동동 407&#10;(한 줄에 주소 하나씩 입력)"></textarea>
            </div>
            <div class="flex flex-col justify-between">
                <div>
                    <p class="text-lg font-semibold text-gray-700 mb-2">또는 CSV 파일 업로드</p>
                    <input type="file" id="csv-file-input" accept=".csv" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-teal-50 file:text-teal-700 hover:file:bg-teal-100"/>
                    <p class="text-xs text-gray-500 mt-2">첫 번째 열에 주소가 포함된 CSV 파일을 업로드하세요.</p>
                </div>
                <button id="start-analysis-btn" class="search-button w-full font-bold py-4 px-8 rounded-lg text-lg mt-4">분석 시작</button>
            </div>
        </div>

        <div id="progress-section" class="hidden pt-6 space-y-2">
            <div class="flex justify-between items-center font-semibold">
                <span id="progress-label" class="text-teal-600">분석 준비 중...</span>
                <span id="progress-text" class="text-gray-700">0 / 0</span>
            </div>
            <div class="progress-bar h-4">
                <div id="progress-bar-fill" class="progress-bar-fill h-4" style="width: 0%;"></div>
            </div>
            <!-- v1.4: 분석 중단 버튼 추가 -->
            <div class="text-center mt-4">
                <button id="cancel-analysis-btn" class="cancel-button font-bold py-2 px-6 rounded-lg text-base">분석 중단</button>
            </div>
        </div>

        <div id="result-section" class="hidden pt-6">
            <div class="flex flex-col sm:flex-row justify-between sm:items-center gap-4 mb-4">
                <h2 class="text-2xl font-bold text-gray-800">종합 분석 결과</h2>
                <button id="download-csv-btn" class="bg-green-600 text-white font-bold py-2 px-4 rounded-lg shadow hover:bg-green-700 transition-colors w-full sm:w-auto">결과 다운로드 (CSV)</button>
            </div>
            <div class="overflow-x-auto border rounded-lg">
                <table class="result-table text-sm">
                    <thead>
                        <tr>
                            <th>No.</th>
                            <th>주소</th>
                            <th>진단 결과</th>
                            <th>최근접 시설</th>
                            <th>거리(m)</th>
                            <th>최고 전압(kV)</th>
                        </tr>
                    </thead>
                    <tbody id="result-table-body">
                    </tbody>
                </table>
            </div>
        </div>
        
    </div>
    
    <!-- v1.4: 토스트 알림을 위한 HTML 요소 추가 -->
    <div id="toast" class="toast-notification"></div>

    <script type="module">
        // --- v1.4: 상수 관리 ---
        // 설정값들을 맨 위에 모아서 관리하기 쉽게 만듭니다.
        const ADDRESS_LIMIT = 200;
        const OVERPASS_API_ENDPOINT = 'https://overpass-api.de/api/interpreter';
        const SEARCH_RADIUS_METERS = 1000;
        const API_REQUEST_DELAY_MS = 500; // API 과부하 방지를 위한 지연 시간

        // --- DOM 요소 가져오기 ---
        const addressListInput = document.getElementById('address-list');
        const csvFileInput = document.getElementById('csv-file-input');
        const startAnalysisBtn = document.getElementById('start-analysis-btn');
        const progressSection = document.getElementById('progress-section');
        const progressLabel = document.getElementById('progress-label');
        const progressText = document.getElementById('progress-text');
        const progressBarFill = document.getElementById('progress-bar-fill');
        const resultSection = document.getElementById('result-section');
        const resultTableBody = document.getElementById('result-table-body');
        const downloadCsvBtn = document.getElementById('download-csv-btn');
        const addressCounter = document.getElementById('address-counter');
        const toast = document.getElementById('toast'); // v1.4 추가
        const cancelAnalysisBtn = document.getElementById('cancel-analysis-btn'); // v1.4 추가

        // --- 전역 변수 ---
        let geocoderInstance = null;
        let analysisResults = [];
        let isAnalysisCancelled = false; // v1.4: 분석 중단 상태를 저장하는 플래그

        // --- 초기화 ---
        kakao.maps.load(() => {
            geocoderInstance = new kakao.maps.services.Geocoder();
        });
        
        // --- 이벤트 리스너 등록 ---
        startAnalysisBtn.addEventListener('click', handleStartAnalysis);
        csvFileInput.addEventListener('change', handleFileUpload);
        downloadCsvBtn.addEventListener('click', downloadResultsAsCsv);
        addressListInput.addEventListener('input', updateAddressCounter);
        cancelAnalysisBtn.addEventListener('click', handleCancelAnalysis); // v1.4 추가

        // --- v1.4: 토스트 알림 함수 ---
        function showToast(message, type = 'info') {
            toast.textContent = message;
            toast.className = 'toast-notification'; // Reset classes
            if (type === 'error') {
                toast.classList.add('error');
            }
            toast.classList.add('show');
            
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000); // 3초 후에 사라짐
        }

        function updateAddressCounter() {
            const addresses = addressListInput.value.split('\n').map(line => line.trim()).filter(line => line);
            const count = addresses.length;
            addressCounter.textContent = `${count} / ${ADDRESS_LIMIT} 개`;
            addressCounter.classList.toggle('over-limit', count > ADDRESS_LIMIT);
        }

        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                const text = e.target.result;
                const lines = text.split('\n').map(line => line.trim()).filter(line => line);
                const addresses = lines.map(line => line.split(',')[0]); 
                addressListInput.value = addresses.join('\n');
                updateAddressCounter();
            };
            reader.readAsText(file);
        }

        // --- v1.4: 분석 중단 처리 함수 ---
        function handleCancelAnalysis() {
            isAnalysisCancelled = true;
            console.log('🚨 분석 중단 버튼 클릭! 중단 플래그를 true로 변경합니다.');
            showToast('분석을 중단하고 있습니다...', 'info');
        }

        async function handleStartAnalysis() {
            const addresses = addressListInput.value.split('\n').map(line => line.trim()).filter(line => line);
            if (addresses.length === 0) {
                showToast('분석할 주소를 입력하거나 CSV 파일을 업로드해주세요.', 'error');
                return;
            }

            if (addresses.length > ADDRESS_LIMIT) {
                showToast(`한 번에 최대 ${ADDRESS_LIMIT}개까지만 분석할 수 있습니다. (현재 ${addresses.length}개)`, 'error');
                return;
            }

            // --- 분석 시작 UI 설정 ---
            startAnalysisBtn.disabled = true;
            startAnalysisBtn.textContent = '분석 중...';
            resultSection.classList.add('hidden');
            progressSection.classList.remove('hidden');
            resultTableBody.innerHTML = '';
            analysisResults = [];
            isAnalysisCancelled = false; // 분석 시작 시 중단 플래그 초기화

            for (let i = 0; i < addresses.length; i++) {
                // v1.4: 루프 시작 전 중단 플래그 확인
                if (isAnalysisCancelled) {
                    console.log('✋ 분석 루프가 중단 플래그를 확인했습니다. 작업을 멈춥니다.');
                    break; // 루프 탈출!
                }

                const address = addresses[i];
                progressLabel.textContent = `[${i + 1}/${addresses.length}] "${address}" 분석 중...`;
                progressText.textContent = `${i + 1} / ${addresses.length}`;
                progressBarFill.style.width = `${((i + 1) / addresses.length) * 100}%`;

                const result = await analyzeSingleAddress(address);
                analysisResults.push(result);
                appendResultToTable(result, i + 1);

                await new Promise(resolve => setTimeout(resolve, API_REQUEST_DELAY_MS));
            }

            // --- 분석 종료 UI 설정 ---
            if (isAnalysisCancelled) {
                progressLabel.textContent = '분석이 사용자에 의해 중단되었습니다.';
            } else {
                progressLabel.textContent = '분석 완료!';
            }
            startAnalysisBtn.disabled = false;
            startAnalysisBtn.textContent = '분석 시작';
            progressSection.classList.add('hidden');
            if (analysisResults.length > 0) {
                resultSection.classList.remove('hidden');
            }
        }

        async function analyzeSingleAddress(address) {
            try {
                const coords = await getCoordsFromAddress(address);
                const facilities = await findFacilities(coords.lat, coords.lon);
                const filtered = filterFacilities(facilities, coords.lat, coords.lon);

                if (filtered.length > 0) {
                    const closest = filtered.sort((a, b) => a.distance - b.distance)[0];
                    const highestVoltage = filtered.reduce((max, el) => parseVoltage(el.tags.voltage) > parseVoltage(max.tags.voltage) ? el : max, filtered[0]);
                    const powerTypes = { substation: '변전소', line: '송전선', tower: '송전탑', cable: '케이블' };
                    
                    return {
                        address,
                        status: '해당',
                        closestFacility: closest.tags.name || powerTypes[closest.tags.power] || '시설',
                        distance: Math.round(closest.distance),
                        highestVoltage: parseVoltage(highestVoltage.tags.voltage) / 1000
                    };
                } else {
                    return { address, status: '해당 없음', closestFacility: '-', distance: '-', highestVoltage: '-' };
                }
            } catch (error) {
                return { address, status: '분석 실패', closestFacility: error.message, distance: '-', highestVoltage: '-' };
            }
        }
        
        function getCoordsFromAddress(address) {
            return new Promise((resolve, reject) => {
                geocoderInstance.addressSearch(address, (result, status) => {
                    if (status === kakao.maps.services.Status.OK) {
                        resolve({ lat: result[0].y, lon: result[0].x });
                    } else {
                        reject(new Error('주소 변환 실패'));
                    }
                });
            });
        }

        async function findFacilities(lat, lon) {
            const query = `[out:json];(node["power"](around:${SEARCH_RADIUS_METERS},${lat},${lon});way["power"](around:${SEARCH_RADIUS_METERS},${lat},${lon});relation["power"](around:${SEARCH_RADIUS_METERS},${lat},${lon}););out center;`;
            const response = await fetch(OVERPASS_API_ENDPOINT, { method: 'POST', body: query });
            if (!response.ok) throw new Error('API 탐색 실패');
            const data = await response.json();
            return data.elements;
        }

        function filterFacilities(elements, centerLat, centerLon) {
            const distanceRules = {
                line: { '765000': 1000, '500000': 800, '345000': 700 },
                substation: { '765000': 850, '500000': 800, '345000': 600 }
            };

            const elementsWithDistance = elements.map(el => {
                const facilityCoords = el.center || el;
                const distance = haversineDistance(centerLat, centerLon, facilityCoords.lat, facilityCoords.lon);
                return { ...el, distance };
            });

            return elementsWithDistance.filter(el => {
                const powerTag = el.tags?.power;
                const voltage = parseVoltage(el.tags?.voltage);
                if (voltage === 0 || !powerTag) return false;
                let ruleType;
                if (['line', 'tower', 'cable'].includes(powerTag)) ruleType = 'line';
                else if (powerTag === 'substation') ruleType = 'substation';
                else return false;
                const ruleVoltage = String(voltage);
                if (!distanceRules[ruleType][ruleVoltage]) return false;
                const maxDistance = distanceRules[ruleType][ruleVoltage];
                return el.distance <= maxDistance;
            });
        }

        function appendResultToTable(result, index) {
            const row = document.createElement('tr');
            const statusClass = result.status === '해당' ? 'status-fail' : (result.status === '해당 없음' ? 'status-pass' : '');
            row.innerHTML = `
                <td class="text-center">${index}</td>
                <td>${result.address}</td>
                <td class="${statusClass}">${result.status}</td>
                <td>${result.closestFacility}</td>
                <td class="text-right">${result.distance}</td>
                <td class="text-right">${result.highestVoltage}</td>
            `;
            resultTableBody.appendChild(row);
        }
        
        function downloadResultsAsCsv() {
            if (analysisResults.length === 0) {
                showToast('다운로드할 결과가 없습니다.', 'error');
                return;
            }
            let csvContent = "data:text/csv;charset=utf-8,\uFEFF"; // BOM for Excel
            csvContent += "No.,주소,진단 결과,최근접 시설,거리(m),최고 전압(kV)\n";

            analysisResults.forEach((result, index) => {
                const row = [
                    index + 1,
                    `"${result.address.replace(/"/g, '""')}"`,
                    result.status,
                    `"${result.closestFacility.toString().replace(/"/g, '""')}"`,
                    result.distance,
                    result.highestVoltage
                ].join(',');
                csvContent += row + "\n";
            });

            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", `GridScan_results_${new Date().toISOString().slice(0,10)}.csv`);
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function haversineDistance(lat1, lon1, lat2, lon2) {
            const R = 6371e3;
            const φ1 = lat1 * Math.PI/180;
            const φ2 = lat2 * Math.PI/180;
            const Δφ = (lat2-lat1) * Math.PI/180;
            const Δλ = (lon2-lon1) * Math.PI/180;
            const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ/2) * Math.sin(Δλ/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        function parseVoltage(voltageTag) {
            if (!voltageTag) return 0;
            if (typeof voltageTag === 'string') {
                const voltages = voltageTag.split(';').map(v => parseInt(v.replace(/\D/g, ''))).filter(v => !isNaN(v));
                return voltages.length > 0 ? Math.max(...voltages) : 0;
            }
            if (typeof voltageTag === 'number') return voltageTag;
            return 0;
        }
    </script>
</body>
</html>